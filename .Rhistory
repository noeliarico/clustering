#if (k == 1L) nmeth <- 3L # Hartigan-Wong, (Fortran) needs k > 1
iter.max <- as.integer(iter.max)
if(is.na(iter.max) || iter.max < 1L) stop("'iter.max' must be positive")
if(ncol(x) != ncol(centers))
stop("must have same number of columns in 'x' and 'centers'")
storage.mode(centers) <- "double"
Z <- Crkmeans()
print("wss")
print(Z$wss)
best <- sum(Z$wss)
print("Best:")
print(best)
#Z$iter <- Z$iter -1 # noelia
if(nstart >= 2L && !is.null(cn)) {
for(i in 2:nstart) {
centers <- cn[sample.int(mm, k), , drop=FALSE]
ZZ <- Crkmeans()
if((z <- sum(ZZ$wss)) < best) {
Z <- ZZ
best <- z
}
}
}
centers <- matrix(Z$centers, k)
dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
cluster <- Z$c1
if(!is.null(rn <- rownames(x)))
names(cluster) <- rn
totss <- sum(scale(x, scale = FALSE)^2)
structure(list(cluster = cluster, centers = centers, totss = totss,
withinss = Z$wss, tot.withinss = best,
betweenss = totss - best, size = Z$nc,
iter = Z$iter, ifault = Z$ifault),
class = "kmeans")
}
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
rkmeans <-
function(x, centers, iter.max = 10L, nstart = 1L, trace = FALSE, distances = 2)
{
#.Mimax <- .Machine$integer.max
# Wrapper for calling the C function that execute kmeans
Crkmeans <- function() {
Z <- .C("rkmeans", x, nobjects, nvariables,
centers = centers, k,
c1 = integer(nobjects), iter = iter.max,
nc = integer(k), wss = wss, ndist = ndist)
if(any(Z$nc == 0)) {
warning("empty cluster: try a better set of initial centers",
call. = FALSE)
Z$ifault <- 2L
}
if(Z$iter > iter.max) {
warning(sprintf(ngettext(iter.max,
"did not converge in %d iteration",
"did not converge in %d iterations"),
iter.max), call. = FALSE, domain = NA)
}
Z
}
x <- as.matrix(x) # data to matrix so it can be used in C
ndist <- as.integer(length(distances))
## as.integer(<too large>) gives NA ==> not allowing too large nrow() / ncol():
nobjects <- as.integer(nrow(x)); if(is.na(nobjects)) stop("Too much objects")
nvariables <- as.integer(ncol(x)); if(is.na(nvariables)) stop("Too much variables")
# Check if the parameter centers is valid
if(missing(centers))
stop("'centers' must be a number or a matrix")
storage.mode(x) <- "double"
if(length(centers) == 1L) {
# Centers can be the number of centers or a vector with an inicilization
# If the center is a number then we create k = centers random centers
k <- centers
## we need to avoid duplicates here
if(nstart == 1L)
centers <- x[sample.int(nobjects, k), , drop = FALSE]
if(nstart >= 2L || any(duplicated(centers))) {
cn <- unique(x)
mm <- nrow(cn)
if(mm < k)
stop("more cluster centers than distinct data points.")
centers <- cn[sample.int(mm, k), , drop=FALSE]
}
} else {
centers <- as.matrix(centers)
if(any(duplicated(centers)))
stop("initial centers are not distinct")
cn <- NULL
k <- nrow(centers)
if(nobjects < k)
stop("more cluster centers than data points")
}
k <- as.integer(k) # Number of clusters to be created
if(is.na(k)) stop("'invalid value of 'k'")
wss <- matrix(rep(double(k), length(distances)), ncol = k)
#wss <- double(k)
#if (k == 1L) nmeth <- 3L # Hartigan-Wong, (Fortran) needs k > 1
iter.max <- as.integer(iter.max)
if(is.na(iter.max) || iter.max < 1L) stop("'iter.max' must be positive")
if(ncol(x) != ncol(centers))
stop("must have same number of columns in 'x' and 'centers'")
storage.mode(centers) <- "double"
Z <- Crkmeans()
print("wss")
print(Z$wss)
best <- sum(Z$wss)
print("Best:")
print(best)
#Z$iter <- Z$iter -1 # noelia
if(nstart >= 2L && !is.null(cn)) {
for(i in 2:nstart) {
centers <- cn[sample.int(mm, k), , drop=FALSE]
ZZ <- Crkmeans()
if((z <- sum(ZZ$wss)) < best) {
Z <- ZZ
best <- z
}
}
}
centers <- matrix(Z$centers, k)
dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
cluster <- Z$c1
if(!is.null(rn <- rownames(x)))
names(cluster) <- rn
totss <- sum(scale(x, scale = FALSE)^2)
structure(list(cluster = cluster, centers = centers, totss = totss,
withinss = Z$wss, tot.withinss = best,
betweenss = totss - best, size = Z$nc,
iter = Z$iter, ifault = Z$ifault),
class = "kmeans")
}
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
rkmeans <-
function(x, centers, iter.max = 10L, nstart = 1L, trace = FALSE, distances = 2)
{
#.Mimax <- .Machine$integer.max
# Wrapper for calling the C function that execute kmeans
Crkmeans <- function() {
Z <- .C("rkmeans", x, nobjects, nvariables,
centers = centers, k,
c1 = integer(nobjects), iter = iter.max,
nc = integer(k), wss = wss, ndist = ndist)
if(any(Z$nc == 0)) {
warning("empty cluster: try a better set of initial centers",
call. = FALSE)
Z$ifault <- 2L
}
if(Z$iter > iter.max) {
warning(sprintf(ngettext(iter.max,
"did not converge in %d iteration",
"did not converge in %d iterations"),
iter.max), call. = FALSE, domain = NA)
}
Z
}
x <- as.matrix(x) # data to matrix so it can be used in C
ndist <- as.integer(length(distances))
## as.integer(<too large>) gives NA ==> not allowing too large nrow() / ncol():
nobjects <- as.integer(nrow(x)); if(is.na(nobjects)) stop("Too much objects")
nvariables <- as.integer(ncol(x)); if(is.na(nvariables)) stop("Too much variables")
# Check if the parameter centers is valid
if(missing(centers))
stop("'centers' must be a number or a matrix")
storage.mode(x) <- "double"
if(length(centers) == 1L) {
# Centers can be the number of centers or a vector with an inicilization
# If the center is a number then we create k = centers random centers
k <- centers
## we need to avoid duplicates here
if(nstart == 1L)
centers <- x[sample.int(nobjects, k), , drop = FALSE]
if(nstart >= 2L || any(duplicated(centers))) {
cn <- unique(x)
mm <- nrow(cn)
if(mm < k)
stop("more cluster centers than distinct data points.")
centers <- cn[sample.int(mm, k), , drop=FALSE]
}
} else {
centers <- as.matrix(centers)
if(any(duplicated(centers)))
stop("initial centers are not distinct")
cn <- NULL
k <- nrow(centers)
if(nobjects < k)
stop("more cluster centers than data points")
}
k <- as.integer(k) # Number of clusters to be created
if(is.na(k)) stop("'invalid value of 'k'")
wss <- matrix(rep(double(k), length(distances)), ncol = k)
#wss <- double(k)
#if (k == 1L) nmeth <- 3L # Hartigan-Wong, (Fortran) needs k > 1
iter.max <- as.integer(iter.max)
if(is.na(iter.max) || iter.max < 1L) stop("'iter.max' must be positive")
if(ncol(x) != ncol(centers))
stop("must have same number of columns in 'x' and 'centers'")
storage.mode(centers) <- "double"
Z <- Crkmeans()
print("wss")
print(Z$wss)
print(ndist)
#Z$iter <- Z$iter -1 # noelia
if(nstart >= 2L && !is.null(cn)) {
for(i in 2:nstart) {
centers <- cn[sample.int(mm, k), , drop=FALSE]
ZZ <- Crkmeans()
if((z <- sum(ZZ$wss)) < best) {
Z <- ZZ
best <- z
}
}
}
centers <- matrix(Z$centers, k)
dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
cluster <- Z$c1
if(!is.null(rn <- rownames(x)))
names(cluster) <- rn
totss <- sum(scale(x, scale = FALSE)^2)
structure(list(cluster = cluster, centers = centers, totss = totss,
withinss = Z$wss, tot.withinss = best,
betweenss = totss - best, size = Z$nc,
iter = Z$iter, ifault = Z$ifault),
class = "kmeans")
}
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
rkmeans <-
function(x, centers, iter.max = 10L, nstart = 1L, trace = FALSE, distances = 2)
{
#.Mimax <- .Machine$integer.max
# Wrapper for calling the C function that execute kmeans
Crkmeans <- function() {
Z <- .C("rkmeans", x, nobjects, nvariables,
centers = centers, k,
c1 = integer(nobjects), iter = iter.max,
nc = integer(k), wss = wss, ndist = ndist)
if(any(Z$nc == 0)) {
warning("empty cluster: try a better set of initial centers",
call. = FALSE)
Z$ifault <- 2L
}
if(Z$iter > iter.max) {
warning(sprintf(ngettext(iter.max,
"did not converge in %d iteration",
"did not converge in %d iterations"),
iter.max), call. = FALSE, domain = NA)
}
Z
}
x <- as.matrix(x) # data to matrix so it can be used in C
ndist <- as.integer(length(distances))
## as.integer(<too large>) gives NA ==> not allowing too large nrow() / ncol():
nobjects <- as.integer(nrow(x)); if(is.na(nobjects)) stop("Too much objects")
nvariables <- as.integer(ncol(x)); if(is.na(nvariables)) stop("Too much variables")
# Check if the parameter centers is valid
if(missing(centers))
stop("'centers' must be a number or a matrix")
storage.mode(x) <- "double"
if(length(centers) == 1L) {
# Centers can be the number of centers or a vector with an inicilization
# If the center is a number then we create k = centers random centers
k <- centers
## we need to avoid duplicates here
if(nstart == 1L)
centers <- x[sample.int(nobjects, k), , drop = FALSE]
if(nstart >= 2L || any(duplicated(centers))) {
cn <- unique(x)
mm <- nrow(cn)
if(mm < k)
stop("more cluster centers than distinct data points.")
centers <- cn[sample.int(mm, k), , drop=FALSE]
}
} else {
centers <- as.matrix(centers)
if(any(duplicated(centers)))
stop("initial centers are not distinct")
cn <- NULL
k <- nrow(centers)
if(nobjects < k)
stop("more cluster centers than data points")
}
k <- as.integer(k) # Number of clusters to be created
if(is.na(k)) stop("'invalid value of 'k'")
wss <- matrix(rep(double(k), length(distances)), ncol = k)
#wss <- double(k)
#if (k == 1L) nmeth <- 3L # Hartigan-Wong, (Fortran) needs k > 1
iter.max <- as.integer(iter.max)
if(is.na(iter.max) || iter.max < 1L) stop("'iter.max' must be positive")
if(ncol(x) != ncol(centers))
stop("must have same number of columns in 'x' and 'centers'")
storage.mode(centers) <- "double"
Z <- Crkmeans()
print("wss")
print(Z$wss)
best <- sum(Z$wss)
print(ndist)
#Z$iter <- Z$iter -1 # noelia
if(nstart >= 2L && !is.null(cn)) {
for(i in 2:nstart) {
centers <- cn[sample.int(mm, k), , drop=FALSE]
ZZ <- Crkmeans()
if((z <- sum(ZZ$wss)) < best) {
Z <- ZZ
best <- z
}
}
}
centers <- matrix(Z$centers, k)
dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
cluster <- Z$c1
if(!is.null(rn <- rownames(x)))
names(cluster) <- rn
totss <- sum(scale(x, scale = FALSE)^2)
structure(list(cluster = cluster, centers = centers, totss = totss,
withinss = Z$wss, tot.withinss = best,
betweenss = totss - best, size = Z$nc,
iter = Z$iter, ifault = Z$ifault),
class = "kmeans")
}
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
set.seed(2020)
out_kmeans <- kmeans(x = points, centers = 3, iter.max = 5, nstart = 10, algorithm = "Lloyd", trace = FALSE)
out_kmeans$tot.withinss
out_kmeans$withinss
out_kmeans$cluster
out_rkmeans$cluster
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
set.seed(2020)
o
set.seed(2020)
out_kmeans <- kmeans(x = points, centers = 3, iter.max = 5, nstart = 10, algorithm = "Lloyd", trace = FALSE)
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
out_kmeans$cluster
out_rkmeans$cluster
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
set.seed(2020)
out_kmeans <- kmeans(x = points, centers = 3, iter.max = 5, nstart = 1, algorithm = "Lloyd", trace = FALSE)
out_kmeans$withinss
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5))
rkmeans <-
function(x, centers, iter.max = 10L, nstart = 1L, trace = FALSE, distances = 2, dist = 2)
{
#.Mimax <- .Machine$integer.max
# Wrapper for calling the C function that execute kmeans
Crkmeans <- function() {
Z <- .C("rkmeans", x, nobjects, nvariables,
centers = centers, k,
c1 = integer(nobjects), iter = iter.max,
nc = integer(k), wss = wss, ndist = ndist, dist = as.integer(dist))
if(any(Z$nc == 0)) {
warning("empty cluster: try a better set of initial centers",
call. = FALSE)
Z$ifault <- 2L
}
if(Z$iter > iter.max) {
warning(sprintf(ngettext(iter.max,
"did not converge in %d iteration",
"did not converge in %d iterations"),
iter.max), call. = FALSE, domain = NA)
}
Z
}
x <- as.matrix(x) # data to matrix so it can be used in C
ndist <- as.integer(length(distances))
## as.integer(<too large>) gives NA ==> not allowing too large nrow() / ncol():
nobjects <- as.integer(nrow(x)); if(is.na(nobjects)) stop("Too much objects")
nvariables <- as.integer(ncol(x)); if(is.na(nvariables)) stop("Too much variables")
# Check if the parameter centers is valid
if(missing(centers))
stop("'centers' must be a number or a matrix")
storage.mode(x) <- "double"
if(length(centers) == 1L) {
# Centers can be the number of centers or a vector with an inicilization
# If the center is a number then we create k = centers random centers
k <- centers
## we need to avoid duplicates here
if(nstart == 1L)
centers <- x[sample.int(nobjects, k), , drop = FALSE]
if(nstart >= 2L || any(duplicated(centers))) {
cn <- unique(x)
mm <- nrow(cn)
if(mm < k)
stop("more cluster centers than distinct data points.")
centers <- cn[sample.int(mm, k), , drop=FALSE]
}
} else {
centers <- as.matrix(centers)
if(any(duplicated(centers)))
stop("initial centers are not distinct")
cn <- NULL
k <- nrow(centers)
if(nobjects < k)
stop("more cluster centers than data points")
}
k <- as.integer(k) # Number of clusters to be created
if(is.na(k)) stop("'invalid value of 'k'")
wss <- matrix(rep(double(k), length(distances)), ncol = k)
#wss <- double(k)
#if (k == 1L) nmeth <- 3L # Hartigan-Wong, (Fortran) needs k > 1
iter.max <- as.integer(iter.max)
if(is.na(iter.max) || iter.max < 1L) stop("'iter.max' must be positive")
if(ncol(x) != ncol(centers))
stop("must have same number of columns in 'x' and 'centers'")
storage.mode(centers) <- "double"
Z <- Crkmeans()
print("wss")
print(Z$wss)
best <- sum(Z$wss)
print(ndist)
#Z$iter <- Z$iter -1 # noelia
if(nstart >= 2L && !is.null(cn)) {
for(i in 2:nstart) {
centers <- cn[sample.int(mm, k), , drop=FALSE]
ZZ <- Crkmeans()
if((z <- sum(ZZ$wss)) < best) {
Z <- ZZ
best <- z
}
}
}
centers <- matrix(Z$centers, k)
dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
cluster <- Z$c1
if(!is.null(rn <- rownames(x)))
names(cluster) <- rn
totss <- sum(scale(x, scale = FALSE)^2)
structure(list(cluster = cluster, centers = centers, totss = totss,
withinss = Z$wss, tot.withinss = best,
betweenss = totss - best, size = Z$nc,
iter = Z$iter, ifault = Z$ifault),
class = "kmeans")
}
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans1 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 1)
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 2)
set.seed(2020)
out_rkmeans1 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 1)
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 2)
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans1 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 1)
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 2)
dyn.load("02.method/distances/distances.so")
dyn.load("02.method/rkmeans/rkmeans.so")
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 4)
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 2)
set.seed(2020)
out_rkmeans1 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 1)
set.seed(2020)
out_rkmeans2 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 2)
set.seed(2020)
out_rkmeans4 <- rkmeans(x = points, centers = 3, iter.max = 5, nstart = 1, trace = FALSE, distances = c(1, 2, 3, 4, 5), dist = 4)
out_rkmeans2$cluster
out_rkmeans1$cluster
out_rkmeans4$cluster
